package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/jhump/protoreflect/desc"
	"github.com/jhump/protoreflect/desc/protoparse"
	_ "github.com/jhump/protoreflect/desc/protoparse"
	"github.com/tigrannajaryan/exp-lazyproto/internal/molecule/src/codec"
)

type Options struct {
	WithPresence bool
}

func Generate(
	protoPath []string, inputProtoFiles []string, outputDir string, options Options,
) error {
	g := generator{
		includePaths:          protoPath,
		outputDir:             outputDir,
		options:               options,
		templateData:          map[string]string{},
		messageDescrToMessage: map[*desc.MessageDescriptor]*Message{},
		enumDescrToEnum:       map[*desc.EnumDescriptor]*Enum{},
	}

	for _, f := range inputProtoFiles {
		if err := g.processFile(f); err != nil {
			return err
		}
	}
	return g.lastErr
}

type generator struct {
	includePaths []string
	outputDir    string

	options Options

	outBuf  *bytes.Buffer
	lastErr error

	file *File

	messagesToGen         []*Message
	messageDescrToMessage map[*desc.MessageDescriptor]*Message

	enumsToGen      []*Enum
	enumDescrToEnum map[*desc.EnumDescriptor]*Enum

	msg          *Message
	field        *Field
	templateData map[string]string
	spaces       int

	useSizedMarshaler bool
}

func (g *generator) processFile(inputFilePath string) error {
	p := protoparse.Parser{
		Accessor: func(filename string) (io.ReadCloser, error) {
			for _, includePath := range g.includePaths {
				f, err := os.Open(path.Join(includePath, filename))
				if err == nil {
					return f, nil
				}
			}
			return nil, fmt.Errorf(
				"file %s not found in paths %v", inputFilePath, g.includePaths,
			)
		},
		IncludeSourceCodeInfo: true,
	}

	fmt.Printf("Reading %s\n", inputFilePath)

	fileDescrs, err := p.ParseFiles(inputFilePath)
	if err != nil {
		return err
	}

	for _, fileDescr := range fileDescrs {
		if err := g.oStartFile(fileDescr); err != nil {
			return err
		}

		// List to generate all enums declared in this file
		g.listAllEnums(nil, fileDescr.GetEnumTypes(), true)

		// List to generate all messages declared in this file
		g.listAllMessages(nil, fileDescr.GetMessageTypes(), true)

		// List and remember all messages in dependencies, but without generating.
		// We need these messages to be available for lookup if they are used as a
		// field type.
		for _, dep := range fileDescr.GetDependencies() {
			g.listAllMessages(nil, dep.GetMessageTypes(), false)
		}

		if err := g.oEnums(); err != nil {
			return err
		}

		if err := g.oMessages(); err != nil {
			return err
		}

		if err := g.formatAndWriteToFile(fileDescr); err != nil {
			return err
		}
	}

	return g.lastErr
}

func (g *generator) oEnums() error {
	for _, enum := range g.enumsToGen {
		if err := g.oEnum(enum); err != nil {
			return err
		}
	}
	return g.lastErr
}

func (g *generator) oMessages() error {
	for _, msg := range g.messagesToGen {
		g.setMessage(msg)

		if err := g.prepareMessage(); err != nil {
			return err
		}

		if err := g.oMessage(); err != nil {
			return err
		}
	}
	return g.lastErr
}

func (g *generator) listAllEnums(
	parent *Message, enums []*desc.EnumDescriptor, toGen bool,
) {
	for _, descr := range enums {
		enum := NewEnum(parent, descr)

		if toGen {
			g.enumsToGen = append(g.enumsToGen, enum)
		}
		g.enumDescrToEnum[descr] = enum
	}
}

func (g *generator) listAllMessages(
	parent *Message, msgs []*desc.MessageDescriptor,
	toGen bool,
) {
	for _, descr := range msgs {
		msg := NewMessage(parent, descr)

		if toGen {
			g.messagesToGen = append(g.messagesToGen, msg)
		}
		g.messageDescrToMessage[descr] = msg

		g.listAllEnums(msg, msg.GetNestedEnumTypes(), toGen)

		g.listAllMessages(msg, msg.GetNestedMessageTypes(), toGen)
	}
}

func (g *generator) formatAndWriteToFile(fdescr *desc.FileDescriptor) error {
	fname := path.Base(strings.TrimSuffix(fdescr.GetName(), ".proto")) + ".pb.go"
	fname = path.Join(g.outputDir, fname)
	fdir := path.Dir(fname)

	fmt.Printf("Generating %s\n", fname)

	if err := os.MkdirAll(fdir, 0700); err != nil {
		return err
	}

	var err error
	f, err := os.Create(fname)
	if err != nil {
		return err
	}

	srcCode, err := format.Source(g.outBuf.Bytes())
	if err != nil {
		f.Write(g.outBuf.Bytes())
		return err
	}

	_, err = f.Write(srcCode)
	return err
}

func (g *generator) oStartFile(fdescr *desc.FileDescriptor) error {
	g.outBuf = bytes.NewBuffer(nil)

	g.o(
		`
// Code generated by lazyproto. DO NOT EDIT.
// source: %s
`, fdescr.GetName(),
	)

	packagePath := strings.Split(fdescr.GetPackage(), ".")

	if len(packagePath) > 0 {
		packageName := packagePath[len(packagePath)-1]
		g.o("package %s", packageName)
		g.o("")
	}

	g.o(
		`
import (
	"fmt"
	"sync"
	"unsafe"

	"github.com/tigrannajaryan/exp-lazyproto"
	"github.com/tigrannajaryan/exp-lazyproto/internal/protomessage"
	"github.com/tigrannajaryan/exp-lazyproto/internal/oneof"

	"github.com/tigrannajaryan/exp-lazyproto/internal/molecule"
	"github.com/tigrannajaryan/exp-lazyproto/internal/molecule/src/codec"
)

var _ = oneof.OneOf{} // To avoid unused import warning.
var _ = unsafe.Pointer(nil) // To avoid unused import warning.
var _ = fmt.Errorf // To avoid unused import warning.

`,
	)

	if g.useSizedMarshaler {
		g.o(`import "github.com/tigrannajaryan/exp-lazyproto/internal/streams/sizedstream"`)
	}

	return g.lastErr
}

func (g *generator) prepareMessage() error {
	for _, field := range g.msg.Fields {
		maskVal := uint64(1) << g.msg.FlagsBitCount
		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			g.msg.HasEmbeddedMessages = true
			flagName := fmt.Sprintf(
				"flags_%s_%s_Decoded", g.msg.GetName(), field.GetCapitalName(),
			)
			g.msg.DecodedFlags = append(
				g.msg.DecodedFlags, flagBitDef{
					flagName: flagName,
					maskVal:  maskVal,
				},
			)
			g.msg.DecodedFlagName[field] = flagName
			g.msg.FlagsBitCount++
		}
	}

	for _, field := range g.msg.Fields {
		g.setField(field)

		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			// Embedded messages don't need a bit for presence since they use
			// non-nil pointer's to indicate presence instead.
			continue
		}

		if g.isOneOfField() {
			// Oneof fields don't need a bit for presence since they use
			// oneof.OneOf's intrinsic ability to indicate presence instead.
			continue
		}

		maskVal := uint64(1) << g.msg.FlagsBitCount

		// Note that embedded messages and oneof fields don't need a bit for presence
		// since they use non-nil pointer's to indicate presence instead.
		if g.options.WithPresence {
			flagName := fmt.Sprintf(
				"flags_%s_%s_Present", g.msg.GetName(), field.GetCapitalName(),
			)
			g.msg.PresenceFlags = append(
				g.msg.PresenceFlags, flagBitDef{
					flagName: flagName,
					maskVal:  maskVal,
				},
			)
			g.msg.PresenceFlagName[field] = flagName
			g.msg.FlagsBitCount++
		}
	}

	if g.msg.FlagsBitCount > 0 {
		switch {
		case g.msg.FlagsBitCount <= 8:
			g.msg.FlagsUnderlyingType = "uint8"
		case g.msg.FlagsBitCount <= 16:
			g.msg.FlagsUnderlyingType = "uint16"
		case g.msg.FlagsBitCount <= 32:
			g.msg.FlagsUnderlyingType = "uint32"
		case g.msg.FlagsBitCount <= 64:
			g.msg.FlagsUnderlyingType = "uint64"
		default:
			return fmt.Errorf("more than 64 bits flags not supported")
		}

		g.msg.FlagsType = fmt.Sprintf("flags_%s", g.msg.GetName())
	}

	return nil
}

func (g *generator) setMessage(msg *Message) {
	g.msg = msg
	g.templateData["$MessageName"] = msg.GetName()
	g.templateData["$messagePool"] = getPoolName(msg.GetName())
}

func (g *generator) setField(field *Field) {
	g.field = field
	g.templateData["$fieldName"] = field.GetName()
	g.templateData["$FieldName"] = field.GetCapitalName()

	fieldMessage := g.messageDescrToMessage[field.GetMessageType()]

	if fieldMessage != nil {
		g.templateData["$fieldTypeMessagePool"] = getPoolName(fieldMessage.GetName())
		g.templateData["$FieldMessageTypeName"] = fieldMessage.GetName()
	} else {
		g.templateData["$fieldTypeMessagePool"] = "$fieldTypeMessagePool not defined for " + field.GetName()
		g.templateData["$FieldMessageTypeName"] = "$FieldMessageTypeName not defined for " + field.GetName()
	}
}

func (g *generator) o(str string, a ...any) {

	str = strings.TrimLeft(str, "\n")

	for k, v := range g.templateData {
		str = strings.ReplaceAll(str, k, v)
	}

	str = fmt.Sprintf(str, a...)

	strs := strings.Split(str, "\n")
	for i := range strs {
		if strings.TrimSpace(strs[i]) != "" {
			strs[i] = strings.Repeat("\t", g.spaces) + strs[i]
		}
	}

	str = strings.Join(strs, "\n")

	_, err := io.WriteString(g.outBuf, str+"\n")
	if err != nil {
		g.lastErr = err
	}
}

func (g *generator) i(ofs int) {
	g.spaces += ofs
}

func (g *generator) convertTypeToGo(field *Field) string {
	var s string

	if field.IsRepeated() {
		s = "[]"
	}

	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		s += "bool"

	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		s += "uint64"

	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		s += "int64"

	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		s += "uint32"

	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		s += "int32"

	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		s += "uint32"

	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		s += "float64"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		s += "string"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		s += "[]byte"
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		s += "*" + g.messageDescrToMessage[field.GetMessageType()].GetName()
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		s += g.enumDescrToEnum[field.GetEnumType()].GetName()
	default:
		g.lastErr = fmt.Errorf("unsupported field type %v", field.GetType())
	}
	return s
}

func getLeadingComment(si *descriptor.SourceCodeInfo_Location) string {
	if si != nil {
		return strings.TrimSpace(si.GetLeadingComments())
	}
	return ""
}

func (g *generator) oMessage() error {
	g.o("// ====================== $MessageName message implementation ======================")
	g.o("")

	if err := g.oMessageStruct(); err != nil {
		return err
	}

	if err := g.oUnmarshalFree(); err != nil {
		return err
	}

	if err := g.oOneOf(); err != nil {
		return err
	}

	if err := g.oFlagConsts(); err != nil {
		return err
	}

	if err := g.oFieldsAccessors(); err != nil {
		return err
	}

	if err := g.oMsgValidateFunc(); err != nil {
		return err
	}

	if err := g.oMsgDecodeFunc(); err != nil {
		return err
	}

	if err := g.oMarshalFunc(); err != nil {
		return err
	}

	if err := g.oPool(); err != nil {
		return err
	}

	g.o("")

	return nil
}

func (g *generator) oComment(comment string) {
	if comment == "" {
		return
	}

	lines := strings.Split(comment, "\n")
	for _, line := range lines {
		g.o("// %s", line)
	}
}

func (g *generator) oMessageStruct() error {
	g.oComment(getLeadingComment(g.msg.GetSourceInfo()))

	g.o("type $MessageName struct {")
	g.i(1)
	g.o("_protoMessage protomessage.ProtoMessage")

	if g.msg.FlagsBitCount > 0 {
		g.o("_flags %s", g.msg.FlagsType)
	}
	g.o("")

	first := true
	for _, field := range g.msg.Fields {
		if field.GetOneOf() != nil {
			// Skip oneof fields for now. They will be generated separately.
			continue
		}
		g.setField(field)
		comment := getLeadingComment(field.GetSourceInfo())
		if !first && comment != "" {
			g.o("")
		}
		g.oComment(comment)
		g.o("$fieldName %s", g.convertTypeToGo(field))
		first = false
	}

	// Generate oneof fields.
	for _, oneof := range g.msg.GetOneOfs() {
		g.o("%s oneof.OneOf", oneof.GetName())
	}
	g.i(-1)
	g.o("}")
	g.o("")

	return g.lastErr
}

func composeOneOfTypeName(msg *Message, oneof *desc.OneOfDescriptor) string {
	return msg.GetName() + capitalCamelCase(oneof.GetName())
}

func composeOneOfChoiceName(msg *Message, choice *Field) string {
	return fmt.Sprintf(
		"%s%s", msg.GetName(), choice.GetCapitalName(),
	)
}

func composeOneOfNoneChoiceName(msg *Message, oneof *desc.OneOfDescriptor) string {
	return msg.GetName() + capitalCamelCase(oneof.GetName()+"None")
}

func (g *generator) oOneOf() error {
	for _, oneof := range g.msg.GetOneOfs() {
		g.oOneOfTypeConsts(oneof)
		g.oOneOfTypeFunc(oneof)
	}

	return g.lastErr
}

func (g *generator) oOneOfTypeConsts(oneof *desc.OneOfDescriptor) {
	typeName := composeOneOfTypeName(g.msg, oneof)
	g.o(
		"// %s defines the possible types for oneof field %q.", typeName,
		oneof.GetName(),
	)
	g.o("type %s int\n", typeName)
	g.o("const (")
	g.i(1)

	noneChoiceName := composeOneOfNoneChoiceName(g.msg, oneof)
	g.o("// %s indicates that none of the oneof choices is set.", noneChoiceName)
	g.o("%s %s = 0", noneChoiceName, typeName)

	for i, choice := range oneof.GetChoices() {
		choiceField := g.msg.FieldsMap[choice.GetName()]
		choiceName := composeOneOfChoiceName(g.msg, choiceField)
		g.o(
			"// %s indicates that oneof field %q is set.", choiceName,
			choiceField.GetName(),
		)
		g.o("%s %s = %d", choiceName, typeName, i+1)
	}

	g.i(-1)
	g.o(")\n")
}

func (g *generator) oOneOfTypeFunc(oneof *desc.OneOfDescriptor) {
	typeName := composeOneOfTypeName(g.msg, oneof)
	funcName := fmt.Sprintf("%sType", capitalCamelCase(oneof.GetName()))
	g.o(
		"// %s returns the type of the current stored oneof %q.", funcName,
		oneof.GetName(),
	)
	g.o("// To set the type use one of the setters.")
	g.o("func (m *$MessageName) %s() %s {", funcName, typeName)
	g.o("	return %s(m.%s.FieldIndex())", typeName, oneof.GetName())
	g.o("}\n")

	funcName = fmt.Sprintf("%sUnset", capitalCamelCase(oneof.GetName()))
	g.o(
		"// %s unsets the oneof field %q, so that it contains none of the choices.",
		funcName, oneof.GetName(),
	)
	g.o("func (m *$MessageName) %s() {", funcName)
	g.o("	m.%s = oneof.NewOneOfNone()", oneof.GetName())
	g.o("}\n")
}

func (g *generator) oUnmarshalFree() error {
	g.o(
		`
func Unmarshal$MessageName(bytes []byte, opts lazyproto.UnmarshalOpts) (*$MessageName, error) {
	var decodeBlock *protomessage.DecodeBlock
	if opts.WithValidate {
		decodeBlock = &protomessage.DecodeBlock{}
		if err := validate$MessageName(bytes, decodeBlock); err != nil {
			return nil, err		
		}
		// decodeBlock.RepeatPtrSlice = make([]unsafe.Pointer, 0, decodeBlock.RepeatPtrCount) 
	}

	m := $messagePool.Get()
	m._protoMessage.Bytes = protomessage.BytesViewFromBytes(bytes)
	m._protoMessage.DecodeBlock = decodeBlock

	if err := m.decode(); err != nil {
		return nil, err
	}
	return m, nil
}

func (m *$MessageName) Free() {
	$messagePool.Release(m)
}
`,
	)
	return g.lastErr
}

func (g *generator) oMsgDecodeFunc() error {

	g.o(
		`
func (m *$MessageName) decode() error {
	buf := codec.NewBuffer(protomessage.BytesFromBytesView(m._protoMessage.Bytes))
`,
	)

	g.i(1)

	if g.msg.FlagsBitCount > 0 {
		g.o(`// Reset all "decoded" and "presence" flags.`)
		g.o("m._flags = 0\n")
	}

	g.oCalcRepeatedFieldCounts()

	g.oMsgDecodeLoop(decodeFull)

	g.i(-1)

	g.o(
		`
	return nil
}
`,
	)

	return g.lastErr
}

func (g *generator) oMsgValidateFunc() error {

	g.o(
		`
func validate$MessageName(b []byte, decodeBlock *protomessage.DecodeBlock) error {
	buf := codec.NewBuffer(b)
`,
	)

	g.i(1)
	g.oMsgDecodeLoop(decodeValidate)
	g.i(-1)

	g.o(
		`
	return nil
}
	`,
	)

	return g.lastErr
}

var protoTypeToWireType = map[descriptor.FieldDescriptorProto_Type]codec.WireType{
	descriptor.FieldDescriptorProto_TYPE_DOUBLE:   codec.WireFixed64,
	descriptor.FieldDescriptorProto_TYPE_FLOAT:    codec.WireFixed32,
	descriptor.FieldDescriptorProto_TYPE_INT64:    codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_UINT64:   codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_INT32:    codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_FIXED64:  codec.WireFixed64,
	descriptor.FieldDescriptorProto_TYPE_FIXED32:  codec.WireFixed32,
	descriptor.FieldDescriptorProto_TYPE_BOOL:     codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_STRING:   codec.WireBytes,
	descriptor.FieldDescriptorProto_TYPE_MESSAGE:  codec.WireBytes,
	descriptor.FieldDescriptorProto_TYPE_BYTES:    codec.WireBytes,
	descriptor.FieldDescriptorProto_TYPE_UINT32:   codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_ENUM:     codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_SFIXED32: codec.WireFixed32,
	descriptor.FieldDescriptorProto_TYPE_SFIXED64: codec.WireFixed64,
	descriptor.FieldDescriptorProto_TYPE_SINT32:   codec.WireVarint,
	descriptor.FieldDescriptorProto_TYPE_SINT64:   codec.WireVarint,
}

func (g *generator) oMsgDecodeLoop(mode decodeMode) error {
	g.o(
		`
for !buf.EOF() {
	// We need to read a varint that represents the key that encodes the field number
	// and wire type. Speculate that the varint is one byte length and switch on it.
	// This is the hot path that is most common when field number is <= 15. 
	b := buf.PeekByteUnsafe()
	switch b {`,
	)

	g.i(1)
	var slowFields []*Field
	for _, field := range g.msg.Fields {
		if field.GetNumber() <= 15 {
			wireType, ok := protoTypeToWireType[field.GetType()]
			if ok {
				g.o(
					"case 0b0_%04b_%03b: // field number %d (%s), wire type %d (%s)",
					field.GetNumber(), wireType,
					field.GetNumber(), field.GetName(), wireType,
					wireTypeToString[wireType],
				)
				g.o("	buf.SkipByteUnsafe()")
				g.setField(field)
				g.oDecodeField(mode, false)
				continue
			}
		}
		slowFields = append(slowFields, field)
	}

	g.o(
		`
default:
	// Our speculation was wrong. Do the full (slow) decoding.`,
	)
	g.i(1)

	g.o(
		`
v, err := buf.DecodeVarint()
if err != nil {
	return err
}
fieldNum, wireType, err := codec.AsTagAndWireType(v)
if err != nil {
	return err
}
`,
	)

	g.o("switch fieldNum {")
	for _, field := range slowFields {
		g.setField(field)
		g.o("case %d:", field.GetNumber())
		g.i(1)
		g.o("// Field %q", field.GetName())
		g.oDecodeField(mode, true)
		g.i(-1)
	}
	g.o("default:")
	g.o("	// Unknown field number.")
	g.o("	if err := buf.SkipFieldByWireType(wireType); err != nil {")
	g.o("		return err")
	g.o("	}")

	g.o("}") // switch

	g.i(-1)

	g.o("}") // switch

	g.i(-1)

	g.o(`}`) // func

	return g.lastErr
}

func (g *generator) oDecodeField(mode decodeMode, checkWireType bool) {
	switch mode {
	case decodeValidate:
		fallthrough
	case decodeFull:
		g.oDecodeFieldValidateOrFull(mode, checkWireType)
	case decodeCountRepeat:
		g.oRepeatFieldCount()
	}
}

func (g *generator) oDecodeFieldValidateOrFull(mode decodeMode, checkWireType bool) {
	decode, ok := primitiveTypeDecode[g.field.GetType()]
	if ok {
		decode.mode = mode
		g.oDecodeFieldPrimitive(decode, checkWireType)
	} else if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_ENUM {
		g.oDecodeFieldEnum(
			g.enumDescrToEnum[g.field.GetEnumType()].GetName(), mode, checkWireType,
		)
	} else if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
		g.oDecodeFieldEmbeddedMessage(mode, checkWireType)
	} else {
		g.lastErr = fmt.Errorf("unsupported field type %v", g.field.GetType())
	}
}

func (g *generator) oRepeatFieldCount() {
	if g.field.IsRepeated() {
		counterName := g.field.GetName() + "Count"
		g.o("	%s++", counterName)
		g.o("	buf.SkipRawBytes()")
	} else {
		g.oSkipFieldByWireType()
	}
}

func (g *generator) oSkipFieldByWireType() {
	wireType := protoTypeToWireType[g.field.GetType()]
	switch wireType {
	case codec.WireVarint:
		g.o("buf.SkipVarint()")
	case codec.WireFixed64:
		g.o("buf.SkipFixed64()")
	case codec.WireBytes:
		g.o("buf.SkipRawBytes()")
	case codec.WireFixed32:
		g.o("buf.SkipFixed32()")
	}
}

type decodePrimitive struct {
	asProtoType      string
	oneOfType        string
	expectedWireType codec.WireType
	mode             decodeMode
}

var wireTypeToString = map[codec.WireType]string{
	codec.WireVarint:     "Varint",
	codec.WireFixed64:    "Fixed64",
	codec.WireBytes:      "Bytes",
	codec.WireStartGroup: "StartGroup",
	codec.WireEndGroup:   "EndGroup",
	codec.WireFixed32:    "Fixed32",
}

func (g *generator) oDecodeFieldPrimitive(task decodePrimitive, checkWireType bool) {
	if checkWireType {
		g.o(
			`
if wireType != codec.Wire%s {	
	return fmt.Errorf("invalid wire type %%d for field number %d ($MessageName.$fieldName)", wireType)
}`, wireTypeToString[task.expectedWireType], g.field.GetNumber(),
		)
	}

	if task.mode == decodeValidate {
		switch g.field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			g.o(`err := buf.SkipRawBytes()`)
		default:
			g.o(`_, err := buf.As%s()`, task.asProtoType)
		}
		g.o(
			`
if err != nil {
	return err
}`,
		)
		return
	} else {
		g.o(
			`
v, err := buf.As%s()
if err != nil {
	return err
}`, task.asProtoType,
		)
	}

	if g.field.GetOneOf() != nil {
		choiceName := composeOneOfChoiceName(g.msg, g.field)
		g.o(
			"m.%s = oneof.NewOneOf%s(v, int(%s))", g.field.GetOneOf().GetName(),
			task.oneOfType, choiceName,
		)
	} else if g.field.IsRepeated() {
		counterName := g.field.GetName() + "Count"
		g.o(
			`
// The slice is pre-allocated, assign to the appropriate index.
m.$fieldName[%[1]s] = v
%[1]s++`, counterName,
		)
	} else {
		g.o("m.$fieldName = v")
		if g.options.WithPresence {
			g.o("m._flags |= %s", g.msg.PresenceFlagName[g.field])
		}
	}
}

func (g *generator) oDecodeFieldEnum(
	enumTypeName string, mode decodeMode, checkWireType bool,
) {

	if checkWireType {
		g.o(
			`
if wireType != codec.WireVarint {	
	return fmt.Errorf("invalid wire type %%d for field number %d ($MessageName.$fieldName)", wireType)
}`, g.field.GetNumber(),
		)
	}

	g.o(
		`
v, err := buf.AsUint32()
if err != nil {
	return err
}`,
	)

	if mode == decodeValidate {
		g.o(`_ = v`)
		return
	}

	g.o(`m.$fieldName = %s(v)`, enumTypeName)
	if g.options.WithPresence {
		g.o("m._flags |= %s", g.msg.PresenceFlagName[g.field])
	}
}

type decodeMode int

const (
	decodeValidate    decodeMode = 0
	decodeFull        decodeMode = 1
	decodeCountRepeat decodeMode = 2
)

var primitiveTypeDecode = map[descriptor.FieldDescriptorProto_Type]decodePrimitive{
	descriptor.FieldDescriptorProto_TYPE_BOOL: {
		asProtoType:      "Bool",
		oneOfType:        "Bool",
		expectedWireType: codec.WireVarint,
	},

	descriptor.FieldDescriptorProto_TYPE_FIXED64: {
		asProtoType:      "Fixed64",
		oneOfType:        "Int64",
		expectedWireType: codec.WireFixed64,
	},

	descriptor.FieldDescriptorProto_TYPE_UINT64: {
		asProtoType:      "Uint64",
		oneOfType:        "Uint32",
		expectedWireType: codec.WireVarint,
	},

	descriptor.FieldDescriptorProto_TYPE_SFIXED64: {
		asProtoType:      "SFixed64",
		oneOfType:        "Int64",
		expectedWireType: codec.WireFixed64,
	},

	descriptor.FieldDescriptorProto_TYPE_INT64: {
		asProtoType:      "Int64",
		oneOfType:        "Int64",
		expectedWireType: codec.WireVarint,
	},

	descriptor.FieldDescriptorProto_TYPE_FIXED32: {
		asProtoType:      "Fixed32",
		oneOfType:        "Int32",
		expectedWireType: codec.WireFixed32,
	},

	descriptor.FieldDescriptorProto_TYPE_SINT32: {
		asProtoType:      "Sint32",
		oneOfType:        "Sint32",
		expectedWireType: codec.WireVarint,
	},

	descriptor.FieldDescriptorProto_TYPE_UINT32: {
		asProtoType:      "Uint32",
		oneOfType:        "Uint32",
		expectedWireType: codec.WireVarint,
	},

	descriptor.FieldDescriptorProto_TYPE_DOUBLE: {
		asProtoType:      "Double",
		oneOfType:        "Double",
		expectedWireType: codec.WireFixed64,
	},

	descriptor.FieldDescriptorProto_TYPE_STRING: {
		asProtoType:      "StringUnsafe",
		oneOfType:        "String",
		expectedWireType: codec.WireBytes,
	},

	descriptor.FieldDescriptorProto_TYPE_BYTES: {
		asProtoType:      "BytesUnsafe",
		oneOfType:        "Bytes",
		expectedWireType: codec.WireBytes,
	},
}

func (g *generator) oDecodeFieldEmbeddedMessage(mode decodeMode, checkWireType bool) {

	if checkWireType {
		g.o(
			`
if wireType != codec.WireBytes {
	return fmt.Errorf("invalid wire type %%d for field number %d ($MessageName.$fieldName)", wireType)
}`, g.field.GetNumber(),
		)
	}

	if mode == decodeValidate {
		g.o(
			`
v, err := buf.DecodeRawBytes()
if err != nil {
	return err
}
err = validate$FieldMessageTypeName(v, decodeBlock)
if err != nil {
	return err
}`,
		)
		if g.field.IsRepeated() && g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			g.o("decodeBlock.RepeatPtrCount++")
		}
	} else {

		g.o(
			`
v, err := buf.AsBytesUnsafe()
if err != nil {
	return err
}
`,
		)

		if g.field.IsRepeated() {
			counterName := g.field.GetName() + "Count"
			g.o(
				`
// The slice is pre-allocated, assign to the appropriate index.
elem := m.$fieldName[%[1]s]
%[1]s++
elem._protoMessage.Parent = &m._protoMessage
elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)`, counterName,
			)
		} else if g.field.GetOneOf() != nil {
			choiceName := composeOneOfChoiceName(g.msg, g.field)
			g.o(
				`
elem := $fieldTypeMessagePool.Get()
elem._protoMessage.Parent = &m._protoMessage
elem._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)
m.%s = oneof.NewOneOfPtr(unsafe.Pointer(elem), int(%s))`,
				g.field.GetOneOf().GetName(), choiceName,
			)
		} else {
			g.o(
				`
m.$fieldName = $fieldTypeMessagePool.Get()
m.$fieldName._protoMessage.Parent = &m._protoMessage
m.$fieldName._protoMessage.Bytes = protomessage.BytesViewFromBytes(v)`,
			)
		}
	}
}

func (g *generator) oCalcRepeatedFieldCounts() {
	fields := g.getRepeatedFields()
	if len(fields) == 0 {
		return
	}

	g.o("")
	g.o("// Count all repeated fields. We need one counter per field.")

	for _, field := range fields {
		g.setField(field)
		counterName := field.GetName() + "Count"
		g.o("%s := 0", counterName)
	}

	g.oMsgDecodeLoop(decodeCountRepeat)

	g.o("")
	g.o("// Pre-allocate slices for repeated fields.")

	for _, field := range fields {
		g.setField(field)
		counterName := field.GetName() + "Count"

		if field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			g.o("m.$fieldName = $fieldTypeMessagePool.GetSlice(%s)", counterName)
		} else {
			g.o("m.$fieldName = make(%s, %s)", g.convertTypeToGo(field), counterName)
		}
	}
	g.o("")
	g.o("// Reset the buffer to start iterating over the fields again")
	g.o("buf.Reset(protomessage.BytesFromBytesView(m._protoMessage.Bytes))")
	g.o("")
	g.o("// Set slice indexes to 0 to begin iterating over repeated fields.")
	for _, field := range fields {
		g.setField(field)
		counterName := field.GetName() + "Count"
		g.o("%s = 0", counterName)
	}
}

func (g *generator) getRepeatedFields() []*Field {
	var r []*Field
	for _, field := range g.msg.Fields {
		if field.IsRepeated() {
			r = append(r, field)
		}
	}
	return r
}

func (g *generator) oFlagConsts() error {
	if len(g.msg.DecodedFlags) > 0 || len(g.msg.PresenceFlags) > 0 {
		g.o("// %s is the type of the bit flags.", g.msg.FlagsType)
		g.o("type %s %s", g.msg.FlagsType, g.msg.FlagsUnderlyingType)
	}

	if len(g.msg.DecodedFlags) > 0 {
		g.o("// Bitmasks that indicate that the particular nested message is decoded.")
		for _, bitDef := range g.msg.DecodedFlags {
			g.o(
				"const %s %s = 0x%X", bitDef.flagName, g.msg.FlagsType,
				bitDef.maskVal,
			)
		}
		g.o("")
	}

	if len(g.msg.PresenceFlags) > 0 {
		g.o("// Bitmasks that indicate that the particular field is present.")
		for _, bitDef := range g.msg.PresenceFlags {
			g.o(
				"const %s %s = 0x%X", bitDef.flagName, g.msg.FlagsType,
				bitDef.maskVal,
			)
		}
		g.o("")
	}
	return g.lastErr
}

func (g *generator) oFieldsAccessors() error {
	for _, field := range g.msg.Fields {
		g.setField(field)

		if g.options.WithPresence {
			if err := g.oHasField(); err != nil {
				return err
			}
		}

		if err := g.oFieldGetter(); err != nil {
			return err
		}
		if err := g.oFieldSetter(); err != nil {
			return err
		}
	}
	return nil
}

func (g *generator) oFieldGetter() error {
	g.o("// $FieldName returns the value of the $fieldName.")

	if g.field.GetOneOf() != nil {
		g.o(
			`// If the field "%s" is not set to "$fieldName" then the returned value is undefined.`,
			g.field.GetOneOf().GetName(),
		)
	}

	goType := g.convertTypeToGo(g.field)

	g.o("func (m *$MessageName) $FieldName() %s {", goType)

	if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
		g.i(1)
		g.o("if m._flags&%s == 0 {", g.msg.DecodedFlagName[g.field])
		g.i(1)
		g.o("// Decode nested message(s).")
		if g.field.IsRepeated() {
			g.o("for i := range m.$fieldName {")
			g.o("	// TODO: decide how to handle decoding errors.")
			g.o("	_ = m.$fieldName[i].decode()")
			g.o("}")
		} else {
			if g.field.GetOneOf() != nil {
				choiceName := composeOneOfChoiceName(g.msg, g.field)
				g.o(
					"if m.%s.FieldIndex() == int(%s) {", g.field.GetOneOf().GetName(),
					choiceName,
				)
				g.i(1)
				g.o(
					"$fieldName := (*$FieldMessageTypeName)(m.%s.PtrVal())",
					g.field.GetOneOf().GetName(),
				)
			} else {
				g.o("$fieldName := m.$fieldName")
			}

			g.o("if $fieldName != nil {")
			g.o("	// TODO: decide how to handle decoding errors.")
			g.o("	_ = $fieldName.decode()")
			g.o("}")

			if g.field.GetOneOf() != nil {
				g.i(-1)
				g.o("}")
			}
		}
		g.i(-1)

		g.o("	m._flags |= %s", g.msg.DecodedFlagName[g.field])
		g.o("}")
		g.i(-1)
	}

	if g.field.GetOneOf() != nil {
		switch g.field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			g.o("	return m.%s.BoolVal()", g.field.GetOneOf().GetName())

		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			g.o("	return m.%s.Int64Val()", g.field.GetOneOf().GetName())

		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			g.o("	return m.%s.DoubleVal()", g.field.GetOneOf().GetName())
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			g.o("	return m.%s.StringVal()", g.field.GetOneOf().GetName())
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			g.o("	return m.%s.BytesVal()", g.field.GetOneOf().GetName())
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			g.o("	return (%s)(m.%s.PtrVal())", goType, g.field.GetOneOf().GetName())
		default:
			return fmt.Errorf("unsupported oneof field type %v", g.field.GetType())
		}
	} else {
		g.o(`	return m.$fieldName`)
	}
	g.o("}\n")

	return g.lastErr
}

func (g *generator) calcOneOfFieldIndex() int {
	fieldIdx := -1
	if g.field.GetOneOf() == nil {
		return fieldIdx
	}

	for i, field := range g.field.GetOneOf().GetChoices() {
		if g.field.GetNumber() == field.GetNumber() {
			fieldIdx = i
			break
		}
	}
	if fieldIdx == -1 {
		g.lastErr = fmt.Errorf("cannot find index of oneof field %s", g.field.GetName())
	}
	return fieldIdx
}

func (g *generator) isOneOfField() bool {
	return g.calcOneOfFieldIndex() >= 0
}

func (g *generator) oFieldSetter() error {
	g.o("// Set$FieldName sets the value of the $fieldName.")

	if g.field.GetOneOf() != nil {
		g.o(
			`// The oneof field "%s" will be set to "$fieldName".`,
			g.field.GetOneOf().GetName(),
		)
	}

	g.o("func (m *$MessageName) Set$FieldName(v %s) {", g.convertTypeToGo(g.field))

	if g.field.GetOneOf() != nil {
		if !g.isOneOfField() {
			return g.lastErr
		}

		choiceName := composeOneOfChoiceName(g.msg, g.field)

		switch g.field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_BOOL:
			g.o(
				"	m.%s = oneof.NewOneOfBool(v, int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)

		case descriptor.FieldDescriptorProto_TYPE_INT64:
			fallthrough
		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
			g.o(
				"	m.%s = oneof.NewOneOfInt64(v, int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)

		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
			g.o(
				"	m.%s = oneof.NewOneOfDouble(v, int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			g.o(
				"	m.%s = oneof.NewOneOfString(v, int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)
		case descriptor.FieldDescriptorProto_TYPE_BYTES:
			g.o(
				"	m.%s = oneof.NewOneOfBytes(v, int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			g.o(
				"	m.%s = oneof.NewOneOfPtr(unsafe.Pointer(v), int(%s))",
				g.field.GetOneOf().GetName(), choiceName,
			)
		default:
			return fmt.Errorf("unsupported oneof field type %v", g.field.GetType())
		}
	} else {
		g.o("	m.$fieldName = v")
		if g.options.WithPresence {
			if g.field.GetType() != descriptor.FieldDescriptorProto_TYPE_MESSAGE {
				g.o("m._flags |= %s", g.msg.PresenceFlagName[g.field])
			}
		}
	}

	if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
		g.o("")
		g.o("	// Make sure the field's Parent points to this message.")
		if g.field.IsRepeated() {
			g.o("	for _, elem := range m.$fieldName {")
			g.o("		elem._protoMessage.Parent = &m._protoMessage")
			g.o("	}")
		} else {
			g.o("	v._protoMessage.Parent = &m._protoMessage")
		}
	}
	g.o("")
	g.o("	// Mark this message modified, if not already.")
	g.o("	m._protoMessage.MarkModified()")
	g.o("}\n")

	if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE && g.field.IsRepeated() {
		if err := g.oFieldSliceMethods(); err != nil {
			return err
		}
	}

	return g.lastErr
}

func (g *generator) oHasField() error {
	if g.field.GetOneOf() != nil {
		// Has() func is not needed for oneof fields since they have the Type() func.
		return nil
	}

	g.o(`// Has$FieldName returns true if the $fieldName is present.`)
	g.o("func (m *$MessageName) Has$FieldName() bool {")

	g.i(1)

	if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
		if g.field.IsRepeated() {
			g.o("return len(m.$fieldName) > 0")
		} else {
			g.o("return m.$fieldName != nil")
		}
	} else {
		if g.field.GetType() != descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			g.o("return m._flags & %s != 0", g.msg.PresenceFlagName[g.field])
		}
	}

	g.i(-1)
	g.o("}\n")

	return g.lastErr
}

func (g *generator) oFieldSliceMethods() error {
	g.o(
		`
func (m *$MessageName) $FieldNameRemoveIf(f func(*$FieldMessageTypeName) bool) {
	// Call getter to load the field.
	m.$FieldName()

	newLen := 0
	for i := 0; i < len(m.$fieldName); i++ {
		if f(m.$fieldName[i]) {
			continue
		}
		if newLen == i {
			// Nothing to move, element is at the right place.
			newLen++
			continue
		}
		m.$fieldName[newLen] = m.$fieldName[i]
		newLen++
	}
	if newLen != len(m.$fieldName) {
		m.$fieldName = m.$fieldName[:newLen]
		// Mark this message modified, if not already.
		m._protoMessage.MarkModified()
	}
}
`,
	)
	return g.lastErr
}

func (g *generator) oMarshalFunc() error {
	for _, field := range g.msg.Fields {
		g.setField(field)

		if field.IsRepeated() && field.GetType() != descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			// We don't use "prepared" for primitive repeated fields.
			continue
		}

		g.oPrepareMarshalField(field)
	}

	g.o("")
	if g.useSizedMarshaler {
		g.o("func (m *$MessageName) Marshal(ps *sizedstream.ProtoStream) error {")
	} else {
		g.o("func (m *$MessageName) Marshal(ps *molecule.ProtoStream) error {")
	}
	g.i(1)
	g.o("if m._protoMessage.IsModified() {")
	g.i(1)

	// Order the fields by their number to ensure marshaling is done in an
	// order that we can rely on in the tests (same order as other as Protobuf
	// libs so that we can compare the results).
	fields := make([]*Field, len(g.msg.Fields))
	copy(fields, g.msg.Fields)
	sort.Slice(
		fields, func(i, j int) bool {
			return fields[i].GetNumber() < fields[j].GetNumber()
		},
	)

	for _, field := range fields {
		g.setField(field)

		if field.GetOneOf() != nil {
			fieldIndex := g.calcOneOfFieldIndex()
			if fieldIndex != 0 {
				// Already generated this oneof, nothing else to do.
				continue
			}
			g.o("// Marshal %q.", g.field.GetOneOf().GetName())

			typeName := composeOneOfTypeName(g.msg, g.field.GetOneOf())
			g.o("switch %s(m.%s.FieldIndex()) {", typeName, g.field.GetOneOf().GetName())

			// Add the "none" case.
			noneChoiceName := composeOneOfNoneChoiceName(g.msg, g.field.GetOneOf())
			g.o("case %s:", noneChoiceName)
			g.o("	// Nothing to do, oneof is unset.")

			for _, choice := range field.GetOneOf().GetChoices() {
				oneofField := g.msg.FieldsMap[choice.GetName()]
				g.setField(oneofField)
				typeName := composeOneOfChoiceName(g.msg, g.field)
				g.o("case %s:", typeName)
				g.i(1)
				g.oMarshalField()
				g.i(-1)
			}
			g.o("}")
		} else {
			g.oMarshalField()
		}
	}
	g.i(-1)
	g.o("} else {")
	g.o("	// Message is unchanged. Used original bytes.")
	g.o("	ps.Raw(protomessage.BytesFromBytesView(m._protoMessage.Bytes))")
	g.o("}")
	g.o("return nil")
	g.i(-1)
	g.o("}")
	return g.lastErr
}

func embeddedFieldName(msg *Message, field *Field) string {
	return fmt.Sprintf("prepared_%s_%s", msg.GetName(), field.GetCapitalName())
}

func convertProtoTypeToOneOfType(protoType string) string {
	switch protoType {
	case "SFixed64":
		return "Int64"
	case "SFixed32":
		return "Int64"
	default:
		return protoType
	}
}

func (g *generator) oMarshalPreparedField(protoTypeName string) {
	if g.field.GetOneOf() != nil {
		g.o(
			"ps.%[1]sPrepared(prepared_$MessageName_$FieldName, m.%[2]s.%[3]sVal())",
			protoTypeName,
			g.field.GetOneOf().GetName(),
			convertProtoTypeToOneOfType(protoTypeName),
		)
	} else {
		g.o(
			"ps.%sPrepared(prepared_$MessageName_$FieldName, m.$fieldName)",
			protoTypeName,
		)
	}
}

func (g *generator) oMarshalField() {
	g.o(`// Marshal "$fieldName".`)

	if g.field.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
		g.oMarshalMessageTypeField()
		return
	} else if g.field.IsRepeated() {
		g.oMarshalPrimitiveRepeated()
		return
	}

	usePresence := g.options.WithPresence && !g.isOneOfField()

	if usePresence {
		g.o("if m._flags&%s != 0 {", g.msg.PresenceFlagName[g.field])
		g.i(1)
	}

	switch g.field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		g.oMarshalPreparedField("Bool")

	case descriptor.FieldDescriptorProto_TYPE_STRING:
		g.oMarshalPreparedField("String")

	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		g.oMarshalPreparedField("Bytes")

	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		g.oMarshalPreparedField("Fixed64")

	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		g.oMarshalPreparedField("SFixed64")

	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		g.oMarshalPreparedField("Uint64")

	case descriptor.FieldDescriptorProto_TYPE_INT64:
		g.oMarshalPreparedField("Int64")

	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		g.oMarshalPreparedField("Fixed32")

	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		g.oMarshalPreparedField("Uint32")

	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		g.oMarshalPreparedField("Sint32")

	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		g.oMarshalPreparedField("Double")

	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		g.o("ps.Uint32Prepared(prepared_$MessageName_$FieldName, uint32(m.$fieldName))")

	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:

	default:
		g.lastErr = fmt.Errorf("unsupported field type %v", g.field.GetType())
	}

	if usePresence {
		g.i(-1)
		g.o("}")
	}
}

func (g *generator) oMarshalPrimitiveRepeated() {
	switch g.field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		g.oMarshalPrimitiveRepeatedField("Bool")

	case descriptor.FieldDescriptorProto_TYPE_STRING:
		g.oMarshalPrimitiveRepeatedField("String")

	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		g.oMarshalPrimitiveRepeatedField("Bytes")

	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		g.oMarshalPrimitiveRepeatedField("Fixed64")

	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		g.oMarshalPrimitiveRepeatedField("SFixed64")

	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		g.oMarshalPrimitiveRepeatedField("Uint64")

	case descriptor.FieldDescriptorProto_TYPE_INT64:
		g.oMarshalPrimitiveRepeatedField("Int64")

	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		g.oMarshalPrimitiveRepeatedField("Fixed32")

	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		g.oMarshalPrimitiveRepeatedField("Uint32")

	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		g.oMarshalPrimitiveRepeatedField("Sint32")

	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		g.oMarshalPrimitiveRepeatedField("Double")

	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		g.o("ps.Uint32Prepared(prepared_$MessageName_$FieldName, uint32(m.$fieldName))")

	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:

	default:
		g.lastErr = fmt.Errorf("unsupported field type %v", g.field.GetType())
	}
}

func (g *generator) oMarshalPrimitiveRepeatedField(protoTypeName string) {
	g.o("ps.%sPacked(%d, m.$fieldName)", protoTypeName, g.field.GetNumber())
}

func (g *generator) oMarshalMessageTypeField() {
	if g.field.IsRepeated() {
		g.o("for _, elem := range m.$fieldName {")
		g.o("	token := ps.BeginEmbedded()")
		g.o("	if err := elem.Marshal(ps); err != nil {")
		g.o("		return err")
		g.o("	}")
		g.o(
			"	ps.EndEmbeddedPrepared(token, %s)",
			embeddedFieldName(g.msg, g.field),
		)
	} else {
		if g.field.GetOneOf() != nil {
			g.o(
				"$fieldName := (*$FieldMessageTypeName)(m.%s.PtrVal())",
				g.field.GetOneOf().GetName(),
			)
		} else {
			g.o("$fieldName := m.$fieldName")
		}

		g.o("if $fieldName != nil {")
		g.o("	token := ps.BeginEmbedded()")
		g.o("	if err := $fieldName.Marshal(ps); err != nil {")
		g.o("		return err")
		g.o("	}")
		g.o(
			"	ps.EndEmbeddedPrepared(token, %s)",
			embeddedFieldName(g.msg, g.field),
		)
	}
	g.o("}")
}

func (g *generator) oPrepareMarshalField(field *Field) {
	switch field.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		g.o(g.preparedFieldDecl(g.msg, field, "Bool"))

	case descriptor.FieldDescriptorProto_TYPE_STRING:
		g.o(g.preparedFieldDecl(g.msg, field, "String"))

	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		g.o(g.preparedFieldDecl(g.msg, field, "Bytes"))

	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		g.o(g.preparedFieldDecl(g.msg, field, "Fixed64"))

	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		g.o(g.preparedFieldDecl(g.msg, field, "Fixed64"))

	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		g.o(g.preparedFieldDecl(g.msg, field, "Uint64"))

	case descriptor.FieldDescriptorProto_TYPE_INT64:
		g.o(g.preparedFieldDecl(g.msg, field, "Int64"))

	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		g.o(g.preparedFieldDecl(g.msg, field, "Fixed32"))

	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		g.o(g.preparedFieldDecl(g.msg, field, "Uint32"))

	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		g.o(g.preparedFieldDecl(g.msg, field, "Sint32"))

	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		g.o(g.preparedFieldDecl(g.msg, field, "Double"))

	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		g.o(g.preparedFieldDecl(g.msg, field, "Uint32"))

	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		g.o(g.preparedFieldDecl(g.msg, field, "Embedded"))

	default:
		g.lastErr = fmt.Errorf("unsupported field type %v", field.GetType())
	}
}

func unexportedName(name string) string {
	return strings.ToLower(name[0:1]) + name[1:]
}

func (g *generator) oPool() error {
	g.o("")
	g.o(
		`
// Pool of $MessageName structs.
type $messagePoolType struct {
	pool []*$MessageName
	mux  sync.Mutex
}

var $messagePool = $messagePoolType{}

// Get one element from the pool. Creates a new element if the pool is empty.
func (p *$messagePoolType) Get() *$MessageName {
	p.mux.Lock()
	defer p.mux.Unlock()

	// Have elements in the pool?
	if len(p.pool) >= 1 {
		// Get the last element.
		r := p.pool[len(p.pool)-1]
		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-1]
		return r
	}

	// Pool is empty, create a new element.
	return &$MessageName{}
}

func (p *$messagePoolType) GetSlice(count int) []*$MessageName {
	// Create a new slice.
	r := make([]*$MessageName, count)

	p.mux.Lock()
	defer p.mux.Unlock()

	// Have enough elements in the pool?
	if len(p.pool) >= count {
		// Copy the elements from the end of the pool.
		copy(r, p.pool[len(p.pool)-count:])

		// Shrink the pool.
		p.pool = p.pool[:len(p.pool)-count]

		return r
	}

	// Initialize with what remains in the pool.
	copied := copy(r, p.pool)
	p.pool = nil

	if copied < count {
		// Create remaining elements.
		storage := make([]$MessageName, count-copied)
		j := 0
		for ; copied < count; copied++ {
			r[copied] = &storage[j]
			j++
		}
	}

	return r
}`,
	)

	g.oPoolReleaseFuncs()
	g.oPoolRelease()

	return g.lastErr
}

func getPoolName(msgName string) string {
	return unexportedName(msgName) + "Pool"
}

func (g *generator) oPoolReleaseElem() {
	for _, field := range g.msg.Fields {
		g.setField(field)

		if field.GetOneOf() != nil {
			fieldIndex := g.calcOneOfFieldIndex()
			if fieldIndex != 0 {
				// We generate all oneof cases when we see the first field. Skip for the rest.
				continue
			}

			typeName := composeOneOfTypeName(g.msg, field.GetOneOf())
			g.o("switch %s(elem.%s.FieldIndex()) {", typeName, field.GetOneOf().GetName())
			for _, choice := range field.GetOneOf().GetChoices() {
				choiceField := g.msg.FieldsMap[choice.GetName()]
				g.setField(choiceField)
				if choiceField.GetType() == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
					choiceName := composeOneOfChoiceName(g.msg, choiceField)
					g.o("case %s:", choiceName)
					g.i(1)
					g.o(
						"ptr := (*$FieldMessageTypeName)(elem.%s.PtrVal())",
						field.GetOneOf().GetName(),
					)
					g.o("if ptr != nil {")
					g.o("	$fieldTypeMessagePool.Release(ptr)")
					g.o("}")
					g.i(-1)
				}
			}
			g.o("}")
			continue
		}

		if field.GetType() != descriptor.FieldDescriptorProto_TYPE_MESSAGE {
			// Only embedded messages need to be freed.
			continue
		}

		// Not a oneof field.
		g.o("// Release nested $fieldName recursively to their pool.")
		if field.IsRepeated() {
			g.o("$fieldTypeMessagePool.ReleaseSlice(elem.$fieldName)")
		} else {
			g.o("if elem.$fieldName != nil {")
			g.o("	$fieldTypeMessagePool.Release(elem.$fieldName)")
			g.o("}")
		}
	}

	g.o("")
	g.o(
		`
// Zero-initialize the released element.
*elem = $MessageName{}`,
	)
}

func (g *generator) oPoolReleaseFuncs() {
	g.o("")
	g.o(
		`
// ReleaseSlice releases a slice of elements back to the pool.
func (p *$messagePoolType) ReleaseSlice(slice []*$MessageName) {
	for _, elem := range slice {`,
	)

	g.i(2)
	g.oPoolReleaseElem()
	g.i(-2)

	g.o(
		`	}

	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, slice...)
}`,
	)
}

func (g *generator) oPoolRelease() {
	g.o("")
	g.o(
		`
// Release an element back to the pool.
func (p *$messagePoolType) Release(elem *$MessageName) {`,
	)

	g.i(1)
	g.oPoolReleaseElem()
	g.i(-1)

	g.o("")
	g.o(
		`
	p.mux.Lock()
	defer p.mux.Unlock()

	// Add the slice to the end of the pool.
	p.pool = append(p.pool, elem)
}`,
	)
}

func (g *generator) preparedFieldDecl(
	msg *Message, field *Field, prepareFuncNamePrefix string,
) string {
	if g.useSizedMarshaler {
		return fmt.Sprintf(
			"var prepared_%s_%s = sizedstream.Prepare%sField(%d)", msg.GetName(),
			field.GetCapitalName(), prepareFuncNamePrefix, field.GetNumber(),
		)
	} else {
		return fmt.Sprintf(
			"var prepared_%s_%s = molecule.Prepare%sField(%d)", msg.GetName(),
			field.GetCapitalName(), prepareFuncNamePrefix, field.GetNumber(),
		)
	}
}

func (g *generator) oEnum(enum *Enum) error {
	g.oComment(getLeadingComment(enum.GetSourceInfo()))
	g.o(
		`
type %[1]s uint32

const (`, enum.GetName(),
	)

	g.i(1)
	for i, value := range enum.GetValues() {
		comment := getLeadingComment(value.GetSourceInfo())
		if i > 0 && comment != "" {
			g.o("")
		}
		g.oComment(comment)
		g.o(
			"%[1]s_%[2]s %[1]s = %[3]d", enum.GetName(), value.GetName(),
			value.GetNumber(),
		)
	}
	g.i(-1)

	g.o(")")
	g.o("")

	return g.lastErr
}
